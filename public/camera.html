<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bluma -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css">
    
    <title>Camera - CamSalvo</title>
  </head>
  <body>
    <div id="app">
        <section class="hero is-dark is-fullheight" v-show="page == 'setup'">
            <div class="hero-body">
              <div class="">
                <p class="title">
                  Device name
                </p>
                <input class="input is-primary" type="text" placeholder="Name to show in dashboard" style="margin-bottom: 1.5rem;" v-model="device.name">
                <button class="button is-primary" :disabled="device.name.length == 0" v-on:click="page_camera">Next</button>
              </div>
            </div>
        </section>
        <div v-show="page == 'camera'" ref="page-camera">
            <video autoplay style="width:100vw;height:100vh;" ref="video-canvas"></video>
        </div>
    </div>

    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.3.2/socket.io.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.2.20/vue.global.min.js"></script>
    <script>
 
    </script>
    <script>
        const CameraApp = {
            data(){
                return {
                    dashboards: {},
                    socket: undefined,
                    config: undefined,
                    page: "setup",
                    device: {
                        name: "",
                    }
                }
            },
            mounted(){
            },
            methods: {
                async init_config(){
                    response = await fetch('config.json'); 
                    if(!response.ok) return this.dialogue("Error: could not load config.json");
                    this.config = await response.json();
                },
                init_socket(){
                    self = this;
                    socket_url = 'ws://'+this.config.socket_server.address+':'+this.config.socket_server.port+'/camera';
                    console.log(socket_url);
                    this.socket = io(socket_url)
                    this.socket.on('connect', ()=>{
                        self.socket.emit('set_config', {'name': self.device.name});
                    });
                    this.socket.on('connect_error', error=>self.dialogue('could not conenct to socket server. please verify that node.js is up and running with proper config.js'))
                    this.socket.on('reconnect_failed', error=>self.dialogue('internete disconnect! you might move your phone to far away from internet access point'))
                    this.socket.on('add_dashboard', this.add_dashboard)
                    this.socket.on('remove_dashboard', this.remove_dashboard) 
                    this.socket.on('rtc_answer', this.answer_dashboard)                    
                },
                dialogue(message){
                    alert(message);
                },
                async add_dashboard(data){
                    self = this;
                    console.log(self.dashboards);
                    data['dashboard_ids'].forEach(async id=>{
                        if(!(id in self.dashboards)){
                            peer = await self.call_dashboard(id);
                            self.dashboards[id] = {'peerConnection': peer}
                        }
                    })
                }, 
                remove_dashboard(data){
                    self = this;
                    data['dashboard_ids'].forEach(id=>{
                        delete self.dashboards[id]
                    })
                },
                async page_camera(){
                    this.page = 'camera';
                    await this.init_config();
                    await this.init_camera();
                    //await this.$refs['page-camera'].requestFullscreen({navigationUI: 'hide'}).catch(() => dialogue('Cannot request fullscreen'))  
                    await this.init_socket();
                },
                async init_camera(){
                    stream = await navigator.mediaDevices.getUserMedia({"video": this.config.preview})
                    this.$refs['video-canvas'].srcObject = stream
                    track = stream.getVideoTracks()[0];
                    this.device['stream'] = stream;
                    this.device['track'] = track;
                    this.device['settings'] = track.getSettings();
                    this.device['capabilities'] = track.getCapabilities();
                },
                async call_dashboard(dashboard_id){
                    // make RTC call to dashboard
                    self = this;
                    peerConnection = new RTCPeerConnection(this.config.web_rtc);
                    /*
                    this.device['stream'].getTracks().forEach(track =>{
                        console.log("ADD TRACK");
                        peerConnection.addTrack(track, self.device['stream'])
                    });
                    */
                    peerConnection.addTransceiver(this.device['track']);
                    peerConnection.getTransceivers().forEach(t => t.direction = 'sendonly');
                    const offer = await peerConnection.createOffer();
                    //const offer = await peerConnection.createOffer({offerToReceiveVideo: true});
                    await peerConnection.setLocalDescription(new RTCSessionDescription(offer));
                    peerConnection.addEventListener('connectionstatechange', event => {
                        //console.log("PEER STATE: "+peerConnection.connectionState)
                        if(peerConnection.connectionState == 'connected'){
                            console.log('connected!');
                        }
                    });
                    peerConnection.addEventListener('icecandidate', event => {
                        if (!event || !event.candidate) return;
                        self.socket.emit("ice_candidate", {"sender": self.socket.id, "candidate": event.candidate, "receiver": dashboard_id}); 
                    });

                    this.socket.emit('rtc_call', {"sender": this.socket.id,"offer": offer, 'receiver': dashboard_id});
                    return peerConnection;
                },
                async answer_dashboard(data){
                    console.log("ANSWER DASHBOARD");
                    self = this;
                    receiver_id = data['receiver']
                    await self.dashboards[receiver_id]['peerConnection'].setRemoteDescription(
                        new RTCSessionDescription(data.answer)
                    );
                }
            }
        }
        Vue.createApp(CameraApp).mount('#app')        
    </script>

  </body>
</html>